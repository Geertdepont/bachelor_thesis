---
layout: post
title: "Avoid nested callbacks, as they could lead to a “callback hell”. Approximatively, more than 2 levels of callbacks are considered to reduce maintainability
        and understandability. This problem is commonly fixed by taking advantage of the RxJava library."
guideline_id: 10
short_description: "Avoid nested callbacks"
date:   2019-05-21 01:00:32 +0200
categories: generic
doc: "Using too many callbacks leads to unreadable code. 
      These callback hells often arise when multiple server requests need to be performed for one activity. 
      For example, showing the details of users. 
      First you need to know which users exist, and with each username you can request the details. 
      The RxJava library can simplify our code. "

---
<h3>Why?</h3>
Using too many callbacks leads to unreadable code. 
These callback hells often arise when multiple server requests need to be performed for one activity. 
For example, showing the details of users. 
First you need to know which users exist, and with each username you can request the details. 
The RxJava library can simplify our code. 

<h3>Example</h3>

For this example we will look at the [MVVM example][MVVM-example]{:target="_blank"} to retrieve my github contributors.
We use for this example Rxjava in combination with retrofit.
Sometimes it is necessary to have nested callbacks.
Like in this example, where we want to find the contributors of our repository.
We need to know which repositories there are before we can look up, the contributors of the repository.

Our methods <b>getRepositories()</b> and <b>getContributors(String repo)</b>, both return observable 
Values. Which means that this values can be viewed by an Observer, which we need to 
Implement.
<script src="https://gist.github.com/Geertdepont/5e8db18f58cabda7b8200ecdf245c553.js"></script>

We then create a Retrofit class, which returns a Retrofit instance, which will perform our API 
requests to “https://api.github.com/” 

<script src="https://gist.github.com/Geertdepont/fe492764b668d1393b32c7c66868ac24.js"></script>



In our repository, we will return our A Single object. Which either emits one value, or an error 
message. 

<script src="https://gist.github.com/Geertdepont/047f1270a4745522b26927ae208eabfe.js"></script>

The <b>getContributorList()</b> performs for each Repository in my github account a new request.
These repositories are retrieved via the <b>myAPI.getRepositories()</b> request.
Then <b>.flatMapIterable(x -> x)</b> flattens a stream of iterables. So that for each repository, we can fetch the contributors, and sort them based on the amount of contributions.

If we had to write this code without RxJava, we would end up with a for loop within two nested callbacks. Which would lead to ugly code.

Checkout the [RXJava documentation][RX-Java]{:target="_blank"} to understand more about <b>Observers</b> and <b>Observables</b>

Whenever using RXJava or Retrofit do not forget to add these libraries to your app/build.gradle file.

<script src="https://gist.github.com/Geertdepont/d538c636d05bc38007701f306d019750.js"></script>

Checkout our [MVVM example][MVVM-example]{:target="_blank"} to view the complete repository. 

<a href="https://github.com/Geertdepont/bachelor_thesis/tree/master/RxjavaRetrofitGithub" target="_blank"><button type="button" class="btn btn-primary btn-icon-right">Go to the github page</button></a>

This guideline was extracted from:
<table id="guidelinelinks">
  <tr>
    <th>Id</th>
    <th>Guideline</th>
    <th>URL</th>
  </tr>
    <tr>
      <td>144</td>
      <td>No more jumping between callbacks. In this example app, coroutines also completely removed the need of using RxJava. Functions with suspendable points are easier to read and understand than some RxJava operator chains — these chains can quickly become too functional (Having said that, I don’t think that RxJava can be replaced with coroutines in every use case. Observables give us a different kind of expressiveness that can not be mapped one to one to suspendable functions. In particular once constructed observable operator chain allow many events to flow through it, while a suspendable point resumes only once per invocation)</td>
      <td><a href="https://blog.elpassion.com/create-a-clean-code-app-with-kotlin-coroutines-and-android-architecture-components-f533b04b5431" target="_blank">https://blog.elpassion.com/create-a-clean-code-app-with-kotlin-coroutines-and-android-architecture-components-f533b04b5431s</a></td>
    </tr>      
     <tr>
      <td>149</td>
      <td>Another common case is when the loadPosts() method takes a parameter that needs to be fetched from somewhere else, for example an email address provided by the Play Services SDK. It’s likely that the SDK will return the email asynchronously using a callback, meaning that we now have three levels of nested callbacks. If we keep adding complexity, this approach will result into what is known as callback hell.</td>
      <td><a href="https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65" target="_blank”>https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65</a></td>
    </tr>   
    <tr>
      <td>192</td>
      <td>Simplified asynchronous tasks: java threads and futures are complex to manipulate and synchronize if more than one single level of asynchronous execution is required, so by using schedulers we can jump between background and main thread in an easy way (with no extra effort), especially when we need to update the UI. We also avoid what we call a “callback hell”, which makes our code unreadable and hard to follow up.</td>
      <td><a href="https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/" target="_blank”>https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/</a></td>
    </tr>      
</table>

[MVVM-example]: https://github.com/Geertdepont/bachelor_thesis/tree/master/RxjavaRetrofitGithub
[RX-Java]: http://reactivex.io/documentation