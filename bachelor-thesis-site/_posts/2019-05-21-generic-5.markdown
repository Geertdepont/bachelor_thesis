---
layout: post
title: "When starting a new project, carefully select a fitting architectural pattern to adhere to."
guideline_id: 5
short_description: "Select architectual pattern"
date:   2019-05-21 01:00:37 +0200
categories: generic
doc: "Picking the
      right architectural pattern (e.g., MVP or MVVM) for the
      context and business goals of the app is a crucial decision. By
      adhering to an architectural patter selected a priori, separating
      responsibilities into components becomes a more straightforward process, and the growth of architectural technical debt is
      hindered. It is important to note that, when a certain level of
      adaptability/maintainability is not required, the selection of an
      ill-suited architectural pattern might lead to over-engineering.
      Choosing the architectural pattern to adopt is hence a nontrivial decision which should be taken by considering the
      context of apps, and their business/organizational goals."

---
<h3>Why?</h3>
Picking the
right architectural pattern (e.g., MVP or MVVM) for the
context and business goals of the app is a crucial decision. By
adhering to an architectural patter selected a priori, separating
responsibilities into components becomes a more straightforward process, and the growth of architectural technical debt is
hindered. It is important to note that, when a certain level of
adaptability/maintainability is not required, the selection of an
ill-suited architectural pattern might lead to over-engineering.
Choosing the architectural pattern to adopt is hence a nontrivial decision which should be taken by considering the
context of apps, and their business/organizational goals.

<h3>Example</h3>
We created two examples:
<ul>
<li>MVVM example</li>
<li>MVP example</li>
</ul>

Our [MVVM example][architecture-example]{:target="_blank"} depicted:
<figure>
  <img src="/assets/MVVM_depicted.png" alt="MVVM depicted" width="90%">
</figure>

Our [MVVM example][github-page]{:target="_blank"} depicted:
<figure>
  <img src="/assets/MVPLogin_depicted.png" alt="MVVM depicted" width="90%">
</figure>

Both the MVVM architecture and the MVP are both recommended architectures when developing Android applications.
As we can see choosing these architectures each component (model, view, presenter/ ViewModel) has its own responsibilities.
Which makes improves testing and so also maintainability because each component can be tested separately.
So whenever a test fails, it can be directly seen from which component this test fails.

Check out both the [MVVM example][architecture-example]{:target="_blank"} and the [MVP example][github-page]{:target="_blank"} on these links.

<a href="https://github.com/Geertdepont/bachelor_thesis/tree/master/ArchitectureExample" target="_blank"><button type="button" class="btn btn-primary btn-icon-right">MVVM example</button></a>
<a href=" https://github.com/Geertdepont/bachelor_thesis/tree/master/MVPLogin" target="_blank"><button type="button" class="btn btn-primary btn-icon-right">MVP example</button></a>

This guideline was extracted from:
<table id="guidelinelinks">
  <tr>
    <th>Id</th>
    <th>Guideline</th>
    <th>URL</th>
  </tr>
    <tr>
      <td>168</td>
      <td>MVVM can not be justified for small projects.</td>
      <td><a href="https://stfalcon.com/en/blog/post/android-mvvm" target="_blank">https://stfalcon.com/en/blog/post/android-mvvm</a></td>
    </tr>   
    <tr>
      <td>229</td>
      <td>[...] Onion Architecture, Hexagonal Architecture (also known as Ports and Adapters) and the popular Clean Architecture, among other layered architectures. Though these approximations have their own fancy names and could seem completely different, they share a lot in common. In fact, its main intent is the same: Achieve a highlevel separation of concerns by layering.</td>
      <td><a href="http://pguardiola.com/blog/clean-architecture-part-1/" target="_blank">http://pguardiola.com/blog/clean-architecture-part-1/</a></td>
    </tr>        
    <tr>
      <td>230</td>
      <td>[General on styles] There are a lot of scenarios where we aren’t gonna need that level of adaptability. Especially in mobile applications in which the domain logic is really close to the view. Prematurely creating that kind of indirection and isolation is usually a waste of time and it may be a bit overkill.</td>
      <td><a href="http://pguardiola.com/blog/clean-architecture-part-1/" target="_blank">http://pguardiola.com/blog/clean-architecture-part-1/</a></td>
    </tr>       
    <tr>
      <td>118</td>
      <td>Another important thing is different entities for each layer of application. As dependency inversion principle works in the other way works additional fields decreasing. The purpose of different entities for each layer is to reduce the amount of information inner layer may depend on. E.g., you don’t need api version at your entity in domain and presentation layers of your application, you only need this property in data layers.</td>
      <td><a href="https://hackernoon.com/android-clean-architecture-with-kotlin-rxjava-and-dagger-2-6006be2d0c02/" target="_blank">https://hackernoon.com/android-clean-architecture-with-kotlin-rxjava-and-dagger-2-6006be2d0c02/</a></td>
    </tr>    
</table>


[architecture-example]: https://github.com/Geertdepont/bachelor_thesis/tree/master/ArchitectureExample
[github-page]: https://github.com/Geertdepont/bachelor_thesis/tree/master/MVPLogin
[article-page]: https://robertoverdecchia.github.io/papers/ICSA_2019.pdf