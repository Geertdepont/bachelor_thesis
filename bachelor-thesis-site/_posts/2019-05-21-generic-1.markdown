---
layout: post
title: "Decouple components and explicitly inject/manage the dependencies among them"
short_description: "Decouple components"
guideline_id: 1
date:   2019-05-21 01:00:41 +0200
categories: generic
icon: "icon-puzzle-piece"
doc: "Utilizing a dependency injection framework can drastically simplify the management of dependencies between Android architectural components. 
      This supports a clean decoupling of architectural components and avoids unnecessary boilerplate for connecting them."

---
<h3>Why?</h3>
While not strictly necessary, utilizing a dependency injection framework
can drastically simplify the management of dependencies between Android architectural components. 
This supports a clean decoupling of architectural components and avoids unnecessary boilerplate for connecting them.
 Doing so not only improves the maintainability of the app, but also improves its testability by providing the possibility 
 to inject mock implementations. The Dagger framework is commonly recommended to inject dependencies and solve problems 
 afflicting reflection-based solutions.

<h3>Introduction</h3>
Dependency injection is a technique whereby one object supplies dependencies of another object.
So let's say I'm a chef in a kitchen. And I need to make meals for the customers.
But if I don't have the tools to create my dishes, nothing happens. I crash.
So we need someone to supply the tools, which is <b>Dagger</b>.

<b>Dagger</b> tells where all the dependencies are, and tells the objects not to worry. Because Dagger will provide the 
dependencies. To perform this dependency injection, dagger uses the following annotation:

<ul>
  <li><b>@Module and @Provides:</b> These classes provide the dependencies.</li>
  <li><b>@Inject: </b> The field which will be injected, this can be a field, a constructor or a method.</li>
  <li><b>@Component:</b> Which uses the selected modules, and performs the dependency injection.</li>
</ul>



<h3>Example</h3>
We created a simple [MVP login Application][github-page]. The event diagram of the MVP login:

<figure>
  <img src="/assets/MVPLogin_injection.png" alt="Login Injection" width="90%">
</figure>

The lifecycle of our components:
<figure>
  <img src="/assets/Component_lifecycle.png" alt="Login Injection" width="70%">
</figure>

As you can see the AuthComponent gets added to the AppComponent after the validation of the credentials.

We will now focus on the AuthComponent.
The AuthComponent uses the AuthModule. And allows two components to be added to this component: 
<ul>
<li>The GreetComponent</li>
<li>The ViewUserComponent</li>
</ul>

<script src="https://gist.github.com/Geertdepont/b5216a57b6975424936c21f1a3f639df.js"></script>

The AuthModule provides whatever the AuthComponent needs. In this case the AuthComponent only needs to provide the credentials.
So a provideCredentials method is added.

<script src="https://gist.github.com/Geertdepont/533cae68ef7bbfc49a45cde4b8cd30d6.js"></script>

When the validation of the login has succeeded, the AuthComponent gets added to the AppComponent.
Also the credentials from the AuthComponent are being set with the given username.

<script src="https://gist.github.com/Geertdepont/b1509c2930f9f4a6d472329fd8aefffa.js"></script>

After this the GreetComponent gets added to the AuthComponent in the GreetActivity with the <b>setupComponent</b> method. 
And the GreetActivity is injected into the GreetComponent. 
Now everything the GreetActivity needs is taken care of in the greetModule.

<script src="https://gist.github.com/Geertdepont/304f78a0318d31cb565566e7c0adbcb2.js"></script>

Now the only job of the GreetPresenter is to greet the user with it's username, by calling the <b>mGreetView.showMessage(mCredentials.getPersonalizedGreeting()) </b>
method. We do not have to check if the username is set, because Dagger has provided the credentials.

<script src="https://gist.github.com/Geertdepont/7e57da2825201c7246ad8599e9fb9abd.js"></script>

Without Dagger, each component has to specify all its dependencies. 
And multiple null-checks have to be made before using that dependency..

Check out the [Github page][github-page]{:target="_blank"} to view the complete repository.

<a href="https://github.com/Geertdepont/bachelor_thesis/tree/master/MVPLogin" target="_blank"><button type="button" class="btn btn-primary btn-icon-right">Go to the github page</button></a>

This guideline was extracted from:

<table id="guidelinelinks">
  <tr>
    <th>Id</th>
    <th>Guideline</th>
    <th>URL</th>
  </tr>
  <tr>
    <td>197</td>
    <td>Create maps of dependencies. </td>
    <td><a href="https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/" target="_blank" >https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/</a></td>
  </tr>
  <tr>
    <td>99</td>
    <td>Use dagger or service locator</td>
    <td><a href="https://proandroiddev.com/building-modern-apps-using-the-android-architecture-guidelines-3238fff96f14" target="_blank">https://proandroiddev.com/building-modern-apps-using-the-android-architecture-guidelines-3238fff96f14</a></td>
  </tr>
  <tr>
    <td>116</td>
    <td>Dagger2 is used to avoid detailcomplicated boilerplate code of connecting architecture elements one to another</td>
    <td><a href="https://hackernoon.com/android-clean-architecture-with-kotlin-rxjava-and-dagger-2-6006be2d0c02" target="_blank">https://hackernoon.com/android-clean-architecture-with-kotlin-rxjava-and-dagger-2-6006be2d0c02</a></td>
  </tr>
    <tr>
      <td>123</td>
      <td>By injecting mock implementations of respective dependencies to separated classes can make testing much easier.</td>
      <td><a href="https://dev.to/wahibhaq/a-brief-summary-of-thoughts-on-clean-architecture-and-mvp-48h9" target="_blank">https://dev.to/wahibhaq/a-brief-summary-of-thoughts-on-clean-architecture-and-mvp-48h9</a></td>
    </tr>
    <tr>
      <td>212</td>
      <td>Through dagger we can manage the scope of our instances created, which is something really cool and from my point of view, Any object or collaborator in your app should not know anything about instances creation and lifecycle and this should be managed by our dependency injection framework.</td>
      <td><a href="https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank">https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/</a></td>
    </tr>
    <tr>
      <td>194</td>
      <td>Use Dagger as (i) components become reusable (since dependencies can be injected and configured externally), 
      (ii) when injecting abstractions as collaborators, we can just change the implementation of any object without having to make a lot of changes in our codebase, 
      (iii) Dependencies can be injected into a component: 
      it is possible to inject mock implementations of these dependencies which makes testing easier.</td>
      <td><a href="https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/" target="_blank">https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/</a></td>
    </tr>
    <tr>
      <td>213</td>
      <td>The @PerActivity is a custom scoping annotation to permit objects whose lifetime should conform to the life of the activity to be memorized in the correct component.
          I really encourage to do this as a good practice, since we get these advantages:
          The ability to inject objects where and activity is required to be constructed.
          The use of singletons on a per-activity basis.
          The global object graph is kept clear of things that can be used only in activities.</td>
      <td><a href="https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank">https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/</a></td>
    </tr>
    <tr>
      <td>112</td>
      <td>My second tip is to have a core module which will have these main responsitilities:
          <ul>
          <li>Handle global dependency injection.</li>
          <li>Contain extension functions.</li>
          <li>Contain the main framework abstractions.</li>
          <li>Initiate in the main application common 3rd party libraries like Analytics, Crash Reporting</li>
          </ul>
      </td>
      <td><a href="https://fernandocejas.com/2018/05/07/architecting-android-reloaded/" target="_blank">https://fernandocejas.com/2018/05/07/architecting-android-reloaded/</a></td>
    </tr>
    <tr>
      <td>103</td>
      <td>Having DI framework is not a must, you can live without it, but right setup of DI can really make your life easier. There are several libraries which offer ready solutions (e.g. Dagger, Roboguice, Toothpick). You can decide which one will fit best in your project, considering performance and usability. With dependency injection you don’t have to care so much about things like e.g. object creation, passing references, implementing singleton pattern.
      </td>
      <td><a href="https://medium.com/stepstone-tech/considering-architecture-for-android-app-f7f0fabf680a" target="_blank">https://medium.com/stepstone-tech/considering-architecture-for-android-app-f7f0fabf680a</a></td>
    </tr>
    <tr>
      <td>104</td>
      <td> think it is a good practice to wrap libraries with a layer of abstraction, this way you can avoid dependencies from particular library implementation inside your business logic. Also if you decide to change a library to a different one, you won’t have to do refactoring in the entire project, just inside a single repository. It is not necessary to use this pattern for everything, only for libraries which you are not confident you will be using in the future.
      </td>
      <td><a href="https://medium.com/stepstone-tech/considering-architecture-for-android-app-f7f0fabf680a" target="_blank">https://medium.com/stepstone-tech/considering-architecture-for-android-app-f7f0fabf680a</a></td>
    </tr>
    <tr>
      <td>86</td>
      <td>
      The UserRepository class above needs an instance of Webservice to fetch the user's data. It could simply create the instance, but to do that, it also needs to know the dependencies of the Webservice class. Additionally, UserRepository is probably not the only class that needs a Webservice. This situation requires us to duplicate code, as each class that needs a reference to Webservice needs to know how to construct it and its dependencies. If each class creates a new WebService, our app could become very resource heavy.
      </td>
      <td><a href="https://developer.android.com/jetpack/docs/guide" target="_blank">https://developer.android.com/jetpack/docs/guide</a></td>
    </tr>
    <tr>
        <td>85</td>
        <td>. Note: If you're already using a library like RxJava or Agera, you can continue using them instead of LiveData. When you use libraries and approaches like these, however, make sure you handle your app's lifecycle properly. In particular, make sure to pause your data streams when the related LifecycleOwner is stopped and to destroy these streams when the related LifecycleOwner is destroyed. You can also add the android.arch.lifecycle:reactivestreams artifact to use LiveData with another reactive streams library, such as RxJava2.</td>
        <td><a href="https://developer.android.com/jetpack/docs/guide" target="_blank">https://developer.android.com/jetpack/docs/guide</a></td>
    </tr>
    <tr>
        <td>153</td>
        <td> RxJava allows you to manage data via asynchronous streams and gives you many operators that you can apply to the stream in order to transform, filter or combine the data.</td>
        <td><a href="https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65" target="_blank">https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65</a></td>
    </tr>
    <tr>
        <td>155</td>
        <td>RxJava Observables and operators remove the need for having nested callbacks.</td>
        <td><a href="https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65" target="_blank">https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65</a></td>
    </tr>
    <tr>
        <td>218</td>
        <td>RxJava Observables and operators remove the need for having nested callbacks.</td>
        <td><a href="https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65" target="_blank">https://labs.ribot.co.uk/android-application-architecture-8b6e34acda65</a></td>
    </tr>
    <tr>
        <td>252</td>
        <td>[On clean ark] Although it’s a bit hidden, the same data flow inversion principle still holds, because without RxJava presenters were implementing the callback, and with RxJava subscribers are also contained in the outer layer – somewhere in the presenter.</td>
        <td><a href="https://five.agency/android-architecture-part-1-every-new-beginning-is-hard/" target="_blank">https://five.agency/android-architecture-part-1-every-new-beginning-is-hard/</a></td>
    </tr>
    <tr>
        <td>191</td>
        <td>Benefits we get out of this RxJava: Decoupling between Observables and Subscribers: makes maintainability and testing easier.</td>
        <td><a href="https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/" target="_blank">https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/</a></td>
    </tr>
      
</table>


[github-page]: https://github.com/Geertdepont/bachelor_thesis/tree/master/MVPLogin

